# 📆 2021-08-23(Mon)
## ☑️ 오늘 한 일 
1. [ ] 자료구조, 알고리즘 실전문제 (구현문제~ DFS/BFS)
2. [ ] 자바 개념 공부하고 정리하기  
3. [x] 팀 개발을 위한 Git.GitHub 시작하기 (조금이라도 읽고 정리)
4. [ ] 정보처리기사 실기 공부하고 정리하기 (효율적으로 하자)
5. [x] 객체지향의 사실과 오해: 01 협력하는 객체들의 공동체

### ✔️ 오늘 한 일 Review ✔️

#### 팀 개발을 위한 Git.GitHub 시작하기 

##### 7일에 끝내는 Git - 2일차> Chapter 3 
- 커밋: 코드의 변경사항을 묶어 하나의 덩어리로 만드는 것 
    - 새로 만든 커밋은 기존 커밋 다음에 시간순으로 쌓임
    - 여러 명이 협업한다면 특정 기준에서 줄기가 나뉘게 된다.    
  

- 브랜치 (branch): 특정 기준에서 줄기를 나누어 작업할 수 잇는 기능
    - 하나의 개발 브랜치에는 한 사람만 작업해서 올려야 버전이 꼬이지 않는다.
      - 여러 사람이 작업하는 원격저장소에는 미리 브랜치 규칙을 정하는 것이 일반적.
    - 브랜치를 사용하지 않고 개발자들이 커밋을 만들려고 한다면 오류가 난다.
    - 원격저장소에 먼저 푸시한 커밋은 정상적으로 올라가고, 뒤늦게 푸시한 다른 커밋은 ' _**최신 코드에 푸시하라**_ ' 오류가 납니다.   
  

  1. 협업자는 커밋을 올릴 브랜치를 각각 만들고
  2. 자신이 만든 브랜치로 이동한 다음
  3. 브랜치에 커밋을 올리고
  4. 코딩이 완료되면 브랜치를 합치면 된다.    
  

- main : Git이 제공하는 기본적인 브랜치
  - 첫 번째 커밋을 하면 자동으로 'main'라는 이름의 브랜치가 커밋을 가리키게 만든다.
    - '가리킨다'는 브랜치가 단순한 '포인터'이기 때문이다.
  - 브랜치가 포인터라는 것은 그저 커밋을 가리키는 것만으로도 분기를 만들 수 있다는 장점이 있다
  - 프로젝트를 통째로 복사해야 해서 무겁고 시간이 많이 걸리는 svn과 달리 Git은 **가볍고 빠르다.**    
  

- branch를 새로 만들어 commit을 하면 그 커밋을 기준(base)으로 두 가지 버전이 생긴다.   
- checkout : 브랜치를 이동하는 명령어 
- 브랜치 생성시 [main] 브랜치로 이동해서 새로운 브랜치를 생성해야한다. 브랜치 만들 때는 base 브랜치를 잘 설정해야 함
- [main] 브랜치를 기준으로 (큰 줄기) 잡고 잔가지에서 조금씩 수정해서 다시 큰 줄기에 합치는 것.      


- [HEAD]: 특수한 포인터, 프랜치 혹은 커밋을 가리키는 포인터 
  - 브랜치 사이를 마음대로 넘나들 수 있다. 
  - 최신 커밋이 아닌 과거 커밋으로도 이동시킬 수 있다. 
  - [main] 브랜치의 포인터와 [HEAD]가 떨어져있는 것을 '분리된 HEAD (Detached HEAD)'라 한다.   
  

- 병합( merge ) : 두 버전의 합집합을 구하는 것 
  - 커밋과 커밋을 합쳤을 때 새로운 상태라면 '병합 커밋'(merge commit)
  - 새로 상태를 만들어 줄 필요 없이 뒤 커밋을 바꿔주면 될 때 ,'빨리 감기 병합' (Fast-forward)
  - 충돌(Conflict)상태 : 겹친 코드로 어떤 코드를 써야할지 모를 때 
    - 충돌이 난 부분을 확인 후 무엇을 남길지 수동으로 선택
  - [main] 브랜치를 기준으로 병합한다는 것은 합친 결과물을 [main] 브랜치에 반영한다는 것.
  - A 브랜치와 B 브랜치 두 개를 합쳤을 때 만들어진 AB 브랜치를 A 브랜치에 올릴 건지, B 브랜치에 올릴 건지 정하는 것.
  

- 브랜치 합치기 : 병합 커밋 및 충돌 해결
  1. [main] 브랜치를 땡겨와서 나만 쓰는 브랜티에서 먼저 병합해 보고 문제가 없는지 확인한다. 
  2. 병합된 커밋이 문제가 없는 것을 확인하고 나서 병합 커밋을 [main] 브랜치에 반영한다.
    - [main] 브랜치에서 바로 병합해도 괜찮으나 다른 사람이 불편해지는 상황을 방지하기 위해 나만 쓰는 브랜치에서 먼저 병합한다. 


- 풀 리퀘스트 (Pull request): 협력자에게 브랜치 병합을 요청하는 메시지를 보내는 것. 
  - 커밋 후 푸시를 하면 GitHub의 원격저장소에 방금 내가 푸시한 브랜치를 알려준다.
  - [Compare & pull request ]: 풀 리퀘스트를 보낼 수 있는 버튼
    - 최근에 푸시한 브랜치가 있을 때만 보여짐
    - 다른 브랜치로 풀 리퀘스트를 보내고 싶거나 직접 설정을 변경하고 싶다면 [New pull request] 클릭
  - 설정: 베이스 브랜치(base) , 비교 브랜치(compare)
    - 베이스 브랜치 : 병합 결과물이 올라갈, 기준이 되는 브랜치
    - 비교 브랜치 : 현재 기준 브랜치의 비교대상이 되는 브랜치
    - Able to merge : 충돌 없이 브랜치 병합될 수 있다.
    - Reviewers : 협력자, 저장소의 협력자아 여러 명이라면 몇 명을 콕 찝어서 요청가능. 보통 같은 팀원이나 해당 기능과 연관된 동료를 선택.
    - Assignees : 이 풀 리퀘스트를 담당하는 동료. 보통 자기 자신
    - Labels : 풀 리퀘스트에 관한 라벨 ex) 버그, 리뷰 필요, 프런트엔드, 백엔드 등등
  - 협력자가 풀 리퀘스트를 확인하고 새롭게 추가된 코드를 검토할 수 있다. 
    - 코드의 라인마다 댓글을 달 수 있어서 풀 리퀘스트 내부에서 토론을 진행할 수 있다. 
    - 수락(Accept), 수정요청(Request Change), 병합(Merge pull request) 가능


- Git에서 새로운 이력을 업데이트하는 명령은 [패치]다.
- Pull이 실제 코드를 내려받는 데 비해 패치는 그래프만 업데이트한다. (코드와 전혀 상관 없음)
- 태그 : 특정 커밋에 포스트잇을 붙이는 것. 현재 코드 상태를 기록 
  - 태그는 Push 해줘야 원격저장소에서도 볼 수 있다. 

***
###### 프로그램의 버전이란?
- 버전을 올리는 것은 크게 메이저 업그레이드와 마이너 업그레이드로 나뉜다.
  - 메이저 업그레이드 : 사용자들이 크게 느낄 변화 (ex. v2.x -> v3.x)
  - 마이너 업그레이드 : 작은 변화 (ex. v.2.3-> v.2.4)
  - 메인터넌스 ( Maintenance ) : 버그나 유지보수 등 작은 수정이 들어갔을 때 바꾼다.
  - LTS (Long Time Support ) 장기 지원 버전: 일반적인 버전보다 장기간에 걸쳐 지원하도록 특별히 만들어진 버전
- 프로그램을 출시하는 것을 **릴리즈( realease )** 라고 한다.
***
#### 객체지향의 사실과 오해: 01 협력하는 객체들의 공동체
- 객체지향 : 어떤 객체들의 어떤 메시지를 주고받으며 협력하는가
- 객체지향에서 가장 중요한 개념 : **역할, 책임, 협력**
  - 요청과 응답으로 구성된 협력 
    > 일반적으로 하나의 문제를 해결하기 위해 다수의 사람 혹은 역할이 필요하기 때문에 한 사람에 대한 **요청(request)** 이 또 다른 사람에 대한 요청을 유발하는 것이 일반적이다. 따라서 요청은 *연쇄적* 으로 발생한다.
    > 
    > 요청을 받은 사람은 주어진 책임을 다하면서 필요한 지식이나 서브스를 제공한다. 즉, 다른 사람의 요청에 **응답(response)** 한다. 응답 역시 요청의 방향과 반대 방향으로 연쇄적으로 전달된다. 
    >
    > 요청과 응답을 통해 다른 사람과 **협력(collaboration)** ...중략.... 협력의 성공은 특정한 역할을 맡은 각 개인이 얼마나 요청을 성실히 이행하는가에 달려 있다.
    >
  - 협력하는 과정 속에서 역할이 존재 
  - 역할 : 어떤 협력에 참여하는 사람이 협력 안에서 차지하는 **책임** 이나 임무를 의미 
    - 특정한 역할은 특정한 책임을 암시
    > 역할과 책임은 협력이 원할하게 진행되는 데 필요한 핵심적인 구성 요소다.
     사람들이 협력을 위해 특정한 역할을 맡고 역할에 적합한 책임을 수행한다는 사실은 몇가지 중요한 개념을 제시한다.
    >  1. 여러 사람이 동일한 역할을 수행할 수 있다. 
    >  2. 역할은 대체 가능성을 의미한다. 
    >  3. 책임을 수행하는 방법은 자율적으로 선택할 수 있다.
    >     - 다형성: 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있다.
    >  4. 한 사람이 동시에 여러 역할을 수행할 수 있다.
- 협력의 핵심: 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다는 것.
- 시스템은 역할과 책임을 수행하는 객체로 분할된다.
- 시스템의 기능은 객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현된다.
- 객체지향 설계 : 적절한 객체에게 적절한 책임을 할당하는 것에서 시작된다. 
  - 책임: 객체지향 설계의 품질은 결정하는 가장 중요한 요소.
  - 역할: 관련성 높은 책임의 집합
    1. 여러 객체가 동일한 역할을 수행할 수 잇다.
    2. 역할은 대체 가능성을 의미한다.
    3. 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
    4. 하나의 객체가 동시에 여러 역할을 수행할 수 있다.
    5. `유연하고 재사용 가능`한 협력 관계를 구축하는 데 중요한 설계 요소.
  

- 객체: 애플리케이션의 기능을 구현하기 위해 존재. `상태`와 `행동`을 함께 지닌 실체.
  - `협력적` 
    - 협력을 위해 메시지를 전송
    - 메시지를 전송하는 객체(sender)와 메시지를 수신하는 객체(receiver) 사이의 관계로 구성됨.
  - `자율적` : 자신의 상태를 직접 관리하고 상태를 기반으로 스스로 판단하고 행동할 수 있음
    - 데이터와 프로세스를 하나의 틀 안에 함께 묶음 
    - 유지보수가 쉽고 재사용이 용이함
    > 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야 하며, 
    > 객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통해야 한다. 
    > 객체는 다른 객체가 `무엇`을 수행하는지는 알 수 있지만 `어떻게` 수행하는지에 대해서는 알 수 없다.
  - `메서드` : 객체가 수신된 메시지를 처리하는 방법
  - `객체의 자율성을 높이는 핵심`: 외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 **분리**하는 것



    
  

***

## 💡 오늘의 회고 💡

머리 자르러 나갔다가 하루가 다 가버렸다. 또 계획한 것을 절반 이상 못했지만, 객체지향의 사실과 오해 읽기를 시작해서 다행이다. 
> 훌륭한 객체지향 설계자가 되기 위해 거쳐야 할 첫 번째 도전은 코드를 담는 클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하는 것이다. 중요한 것은 어떤 클래스가 필요한가가 아니라 `어떤 객체들이 어떤 메시지를 주고받으며 협력`하는가다. 클래스는 객체들의 협력 관계를 코드로 옮기는 도구에 불과하다.
> 
> ... (중략)....
> 
> 객체지향의 핵심은 클래스가 아니다. 핵심은 적절한 책임을 수행하는 역할 간의 유연하고 견고한 협력 관계를 구축하는 것이다.

책 제목처럼 객체 지향에 대해서 오해를 하고 있었다. 책 내용중 `객체지향이라는 말을 들으면 조건반사적으로 클래스라는 단어를 떠올린다.`라는 구절을 읽었을 때는 뜨끔했다. 내일 읽을 내용이 기대된다..(사실 너무 졸려서 머리가 띵하다. )

내일은 제발 ㅜ 공부해!!!!!

***

## 🎯 내일 할 일 🎯
1. [ ] 자료구조, 알고리즘 실전문제 
2. [ ] 자바 개념 공부하고 정리하기  
3. [ ] 팀 개발을 위한 Git.GitHub 시작하기 (조금이라도 읽고 정리)
4. [ ] 정보처리기사 실기 공부하고 정리하기 (효율적으로 하자)
5. [ ] 객체지향의 사실과 오해: 02 이상한 나라의 객체
***
## 🏁 이번주 목표 🏁
- 이것이 코딩 테스트다 책 끝내기
- 프로그래머스 문제 풀기 
- 팀 개발을 위한 Git, GitHub 끝내기
- 객체지향의 사실과 오해 : 역할, 책임, 협력 관점에서 본 객체지향 끝내기
- 대화의 기술 읽기
- 자바 정리 
- 정보처리기사 실기 정리 