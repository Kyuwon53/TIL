# 📆 2022-03-18(FRI)

## ☑️ 오늘 한 일 📑
- [ ] 읽은 책 서평 작성 (작성완료시 리스트에서 삭제)
    - [x] 자바와 JUnit을 활용한 실용주의 단위 테스트
    - [ ] 리팩토링 2판
- [x] 이펙티브 자바 5-6장
- [x] 알고리즘 레벨2 1문제 이상
- [ ] 줌 클론코딩

<br>

***

### 🔍️ 오늘 무엇을 했나요? Review
#### 자바와 JUnit을 활용한 실용주의 단위 테스트
##### 13장 까다로운 테스트 

- 테스트 관점에서 데이터 의미는 그것을 모두 데이터베이스에 부어 넣는 순간 사라진다. **테스트 안에서 데이터를 생성하고 관리하라**
- 머신에 있는 데이터베이스라면 가장 간단한 경로는 테스트마다 깨끗한 데이터베이스로 시작하는 것이다.

```java
public class controllerTest {

  private Controller controller;
  
  @Before
  public void create() {
    controller = new Controller();
    controller.deleteAll();
  }
  
  @After
  public void cleanup() {
   controller.deleteAll();
  }
}
```
- 매 테스트 자기가 쓸 데이터를 추가하거나 그것으로 작업하면 테스트 간 의존성 문제를 최소화 할 수 있다. 
  - 테스트 간 의존성 문제는 다른 테스트에서 남아 있던 데이터 때문에 어떤 테스트가 망가지는 것을 의미한다. 
- 데이터베이스가 트랜잭션을 지원한다면 테스트마다 트랜잭션을 초기화하고, 테스트가 끝나면 롤백( 보통 `@Before`과 `@After`메서드에 위임)

- 관심사를 분리하라. 의존적인 코드는 고립시켜서 코드 베이스에 만연하지 않도록 하라.
- 느리거나 휘발적인 코드를 목으로 대체하여 단위 테스트의 의존성을 끊어라.

##### 14장 프로젝트에서 테스트 
- CI(지속적 통합)은 코드를 더 자주 통합하고 그 결과를 매번 검증하는 것을 의미 
  - 나쁜 코드를 용납하지 않도록 건강한 동료 압박을 지원한다.
- 설계가 좋을수록 테스트 작성도 쉬워진다. 코드를 좋게 구성하자.
  - 의지가 반영된 좋은 설계는 적은 결함으로 이끄는 100% 커버리지에 도달하게 한다. 
- TDD는 테스트를 자기 충족적인 예언으로 만든다. 작성하려는 코드를 설명하기 위해 단위 테스트를 항상 먼저 작성한다. 
- **팀은 시간이 지나면서 커버리지 퍼센트가 높아져야 하고 적어도 아래 방향으로 내려가면 안된다.**

**자신이 만든 코드에 테스트를 작성하고, 점점 좋아지도록 주의 깊게 테스트 코드를 계속 작성하라.**

#### 프로그래머스 [괄호 변환](https://github.com/Kyuwon53/Python-algorithm/tree/main/programmers/Level2/%EA%B4%84%ED%98%B8%20%EB%B3%80%ED%99%98)
- 재귀 호출을 사용하여 문제 해결 

#### 이펙티브자바 5장 제네릭 
##### 로 타입은 사용하지 말라 
- 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 
- 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다. 
- `class` 리터럴에는 로 타입을 써야 한다. 
- 예를 들어 
  - `Set<Object>`는 어떤 타입 객체도 저장할 수 있는 매개변수화 타입
  - `Set<?>`는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다. 
  
##### 비검사 경고를 제거하라
- 할 수 있는 한 모든 비검사 경고를 제거하라. 모두 제거한다면 그 코드는 타입 안정성이 보장된다. 
  - 타입 안전하다고 확신할 수 있다면 `@SuppressWarnings("unchecked")` 에너테이션을 달아 경고를 숨기자
  - `@SuppressWarnings` 애너테이션은 항상 가능한 한 좁은 범위에 적용하자 
    - 변수 선언, 아주 짧은 메서드, 혹은 생성자
    - 자칫 심각한 경고를 놓칠 수 있으니 좁은 범위에 적용.
    - 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다. 
  
##### 배열보다는 리스트를 사용하라 
- 배열은 공변( 함께 변한다는 뜻 ), 제네릭은 불공변이다. 
- 배열은 실수를 런타임에야 알게 되지만, 리스트를 사용하면 컴파일할 때 바로 알 수 있다. 
- 둘을 섞어쓰다가 오류나 경고를 만나면, 배열을 리스트로 대체하는 방법을 적용하라.

##### 이왕이면 제네릭 타입으로 만들라 
- 일반 클래스를 제네릭 클래스로 만드는 첫 단계는 클래스 선언에 타입 매개변수를 추가하는 일이다. 
- 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 

##### 한정적 와일드카드를 사용해 API 유연성을 높이라
- 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드 카드로 대체하라 
- 와이드카드 타입을 적용하면 API가 훨씬 유연해진다. 
- 생산자는 `extends`를 소비자는 `super`를 사용한다. 
  - `<? extends E>` , `<? super E>`
  - `Comparable`과 `Comparator`는 모두 소비자다. 
  
#### 이펙티브 자바 6장 열거 타입과 애너테이션
##### int 상수 대신 열거 타입을 사용하라 
- 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다. 
- 널리 쓰이는 열거 타입은 톱레벨 클래스로 만들고, 특정 톱레벨 클래스에서만 쓰인다면 해당 클랫의 멤버 클래스로 만든다. 
- 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자. 
- 열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다. 
- 하나의 메서드가 상수별로 다르게 동작해야 할 때는 `switch` 문 대신 상수별 메서드 구현을 사용하자. 
  - 열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용하자. 
  
##### ordinal 메서드 대신 인스턴스 필드를 사용하라 
- 대부분의 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응된다. 
- 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal이라는 메서드를 제공한다. 
- **열거 타입 상수에 연결된 값은 `ordinal` 메서드로 얻지 말고, 인스턴스 필드에 저장하자.**

##### 비트 필드 대신 EnumSet을 사용하라 
- 열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도 비트 필드를 사용할 이유는 없다. 
  - `EnumSet` 클래스가 비트 필드 수준의 명료함과 성능을 제공하고 열거 타입의 장점까지 선사하기 때문

##### ordinal 인덱싱 대신 EnumMap을 사용하라 
- 배열의 인덱스를 얻기 위해 EnumMap을 사용하라 Enum.ordinal을 (웬만해서는) 사용하지 말아야 한다. 
  - 배열은 제네릭과 호환되지 않으니 비검사 형변환을 수행해야 하고 각 인덱스의 의미를 모르니 출력 결과에 직접 레이블을 달아야 한다. 
  - 가장 심각한 건 정확한 정숫값을 사용한다는 것을 직접 보증해야 한다.
  
##### 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라
- 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거타입을 함계 사용해 같은 효과를 낼 수 있다. 

##### 명명 패턴보다 애너테이션을 사용하라 
- 애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다. 

##### `@Override` 애너테이션을 일괄되게 사용하라
- `@Override`는 메서드 선언에만 달 수 있으며, 이 애너테이션이 달렸다는 것은 상위 타입의 메서드를 재정의했음을 뜻한다. 
- 상위 클래스의 메서드를 재정의하려는 모든 메서드에 `@Override` 애너테이션을 달자. 

##### 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라 
- 마커 인터페이스 : 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스
- 마커 애너테이션보다 나은 점
  - 마커 인터페이스를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있다. 
  - 적용 대상을 더 정밀하게 지정할 수 있다. 
  
- 새로 추가하는 메서드 없이 단지 **타입 정의**가 목적이라면 마커 인터페이스를 선택
- 클래스나 인터페이스 외의 프로그램 요소에 마킹해야 하거나, 애너테이션을 적극 활용하는 프레임워크의 일부로 그 마커를 편입시키고자 한다면 마커 애너테이션이 올바른 선택


#### [WebRTC](https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API)
- **WebRTC(Web Real-Time Communication)**은 웹 애플리케이션과 사이트가 중간자 없이 브라우저 간에 오디오나 영상 미디어를 포착하고 마음대로 스트림할 뿐 아니라, 임의의 데이터도 교환할 수 있도록 하는 기술
- `peer-to-peer` 통신이 가능해진다. 
- 영상, 오디오 그리고 텍스트를 보낼 수 있다. 
- 서버를 통해 가는 것이 아니라 브라우저가 다른 브라우저로 직접 연결
- 서버를 사용하면 다른 브라우저가 어디 있는지 알려준다. 다른 브라우저가 어디 있는지 확인되면 직접 전달이 가능해진다.

***

## 💡 오늘 회고

🎯 이번주 목표: **기억보단 기록**

***

## 🎯 내일 할 일 🎯
- [ ] 읽은 책 서평 작성 (작성완료시 리스트에서 삭제)
    - [ ] 리팩토링 2판
- [ ] JPA 6-7장
- [ ] 알고리즘 레벨2 1문제 이상
- [ ] 줌 클론코딩
- [ ] 프로그래머의 뇌 읽기

***

## 🏁 이번주 목표 🏁

- [x] 알고리즘 시작하기
- [ ] 이펙티브 자바 8장까지 읽기
- [x] 프로그래머의 뇌 스터디
- [ ] JPA 프로그래밍 7장까지 읽기
- [x] 읽은 책들 서평 작성
- [ ] 노션 시작
- [ ] 줌 클론코딩 끝내기
- [ ] 개인 프로젝트 작업하기 