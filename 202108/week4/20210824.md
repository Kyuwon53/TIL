# 📆 2021-08-24(Tue)
## ☑️ 오늘 한 일 
1. [x] 자료구조, 알고리즘 실전문제 
2. [x] 자바,스프링 등 개념 공부하고 정리하기  
3. [x] 팀 개발을 위한 Git.GitHub 시작하기 chapter 04 
4. [ ] 정보처리기사 실기 공부하고 정리하기 (효율적으로 하자)
5. [x] 객체지향의 사실과 오해: 02 이상한 나라의 객체

### ✔️ 오늘 한 일 Review ✔️

#### 객체지향의 사실과 오해: 02 이상한 나라의 객체 [>>>](https://github.com/Kyuwon53/library_books_record/blob/main/The_Essence_of_Object-Orientation/Chapter02-Objects_in_wonderland.md)
***
#### 객체지향의 사실과 오해: 02 이상한 나라의 객체
> "행동이 상태를 결정한다."

###### 객체
- 객체란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.


- 사용자는 객체가 제공하는 명령 버튼과 쿼리 버튼으로 구성된 인터페이스를 통해서만 객체에 접근할 수 있다.


- 캡슐화  : 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 

  - 협력을 단순하고 유연하게 만든다.
  
###### 상태
- 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현.
- 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다.


- 프로퍼티(property) : 객체의 상태를 구성하는 모든 특징
  - 일반적으로 프로퍼티는 변경되지 않고 고정되기 때문에 `정적`이다.
  - `프로퍼티 값`은 시간이 흐름에 따라 변경되기 때문에 `동적`이다.

       
###### 행동

- 객체의 행동은 상태를 변경시키지만 행동의 결과는 `객체의 상태에 의존적`.
- 객체의 행동은 상태에 영향을 받고, 상태를 변경시킨다.
- 객체의 행동은 객체가 `협력에 참여`할 수 있는 유일한 방법.
- 객체는 수신된 메시지에 따라 적절히 행동하면서 협력에 참여하고 그 결과로 자신의 상태를 변경한다.
 
###### 식별자
- 객체를 서로 `구별`할 수 있는 특정한 프로퍼티
- 모든 객체는 식별자를 가지며 식별자를 이용해 객체를 구별할 수 있다. 

> 객체의 적합성을 결정하는 것은 상태가 아니라 객체의 행동이다.
> 
- 객체지향 설계 : 필요한 협력 고려 => 협력에 필요한 행동 결정 => 행동을 수행할 객체 선택
  - 객체의 행동: 협력에 참여하면서 완수해야 하는 책임을 의미
  
***
#### 팀 개발을 위한 Git.GitHub 시작하기 

##### 7일에 끝내는 Git - 2일차> Chapter 4 : 둘 이상의 원격저장소로 협업하기 
- fork : 남의 원격저장소를 복사해서 내 계정의 원격저장소로 복사.
- clone : 원격저장소를 로컬저장소로 가져온다.
  
###### 평행세계를 만드는 브랜치(branch), 평행우주를 만드는 포크(fork)
- 원격저장소에 커밋을 직접 푸시할 수 있는 사람은 원격저장소를 만든 본인(소유자)뿐
- 다른 사람이 푸시하려면 원격저장소의 소유자가 협력자로 등록을 해야 한다. 
- 등록되지 않은 사람이 푸시를 하면 에러가 난다. 
- 협력자 등록: [Settings - Collaborators - Add collaborator ]

- 원격저장소를 자신의 계정에 fork해서 원격저장소를 생성하고, 이곳에 commit을 올린 후 소유자에게 merge를 요청 하면 소유자는 개발자의 merge요청을 검토해서 원격 저장소에 반영
  - => branch를 통해 코드 분기점을 만들고 pull request를 통해 확인하고 merge하는 과정.    
        ( fork한 원격저장소의 branch에서 원본의 원격저장소의 branch로 풀 리퀘스트를 보내는 것 )
    

- 브랜치 : 하나의 원격저장소에서 `분기(branch)`를 나눈다.
  - 하나의 원격저장소에서 코드 커밋 이력을 편하게 볼 수 있다. 
  - 다수의 사용자가 다수의 브랜치를 만들면 관리하기 힘들다.
  

- 포크 : 여러 원격저장소를 만들어 분기`(branch)`를 나눈다.
  - 원본 원격저장소의 이력을 보려면 따로 주소를 추가해야 한다.
  - 원본 원격저장소에 영향을 미치지 않으므로 내 원격저장소에서 마음껏 코드를 수정할 수 있다. 

- [File changed] : 어떤 새로운 코드가 풀 리퀘스트에 담겨 있는지 확인할 수 있다. 
- 변경된 코드의 왼쪽에서 [+] 버튼을 클릭해서 코드 라인별로 댓글을 달 수 있다. 
- 수정사항을 제안하거나 질문 가능. 코드리뷰 후 [Revuew changes]->[Write]
  - [Comment] : 댓글기능
  - [Approve] -> [Submit review] : 병합
  - [Request changes] : 수정 요청
  - [Merge pull request] -> [confirm merge] : 풀 리퀘스트를 병합 (원본 원격저장소 주인만 가능)
  - 병합이 성공적으로 완료되면 `<name> merge commit` 메시지가 뜬다. 

###### 묵은 커밋을 새 커밋으로 이력 조작하기 ( rebase )
- 풀 리퀘스트를 보냈을 때 충돌이 난다면 두가지 방법이 있다. 
  1. 현재 커밋과 병합(merge)하고 싶은 커밋을 미리 내 브랜치에서 병합해서 병합 커밋을 만들고 이를 풀 리퀘스트로 보내는 방법
    - 나의 풀 리퀘스트에 불 필요한 병합 커밋의 이력이 남는다.=> 충돌을 해결하느라 쓸데없는 코드가 더 들어간 것
  2. 묵은 커밋을 방금 한 커밋처럼: 리베이스(rebase)
    - 커밋의 베이스를 다시 잡는 것
    - 내 브랜치에 내 변경사항만 남길 수 있다는 장점 
    - 리베이스는 히스토리를 `강제로` 조작하기 때문에 다른 사람이 만약 이 히스토리를 보고 있다면 완전히 꼬인다.
    - 반드시 혼자만 쓰는 브랜치에서 수행해야한다.
    - 리베이스는 커밋을 하나씩 비교하면서 충돌이 있나 없나 확인하기 때문에 계속 같은 곳을 수정했다면 충돌이 여러 번 날 수도 있다. 
    - 리베이스는 강제로 이력을 조작하는 행위이기 때문에 `강제 푸시`를 해야한다. 


###### 소스트리에서 여러 원격저장소 히스토리 한 눈에 보기 : 리모트 추가 (Add remote)
  - 소스트리가 원본저장소와 원격저장소를 동시에 추적하도록 만들기
    - 하나의 로컬저장소에서 두 개 이상의 원격저장소를 바라보기 
  - `upstream` : 원본저장소를 지칭하는 관용적 닉네임 
- 패치(Fetch) : [upstream] 원본저장소에 있는 커밋 히스토리를 받아오는 것. `새로고침`
  - 원본저장소 이력을 업데이트한다.
  - 이력만 가져오기 때문에 코드에 영향은 없다.
  
###### 프로필 첫 페이지 
- [Your profile] -> [Customize your pins] : 프로필 첫 페이지에 노출되는 원본저장소 목록을 지정할 수 있다.


  
***
####  개념 정리 
###### WAS(Web Application Server)
- 웹 브라우저와 같은 클라이언트로부터 웹 서버가 요청을 받으면 애플리케이션에 대한 로직을 싱핼하여 웹 서버로 다시 반환해주는 소프트웨어 
- 웹 서버와 DBMS 사이에서 동작하는 `미들웨어`로써, 컨테이너 기반으로 동작
  - 미들웨어: 공통 서비스 및 기능을 애플리케이션에 제공하는 소프트웨어 
    - 데이터 관리, 애플리케이션 서비스, 메시징, 인증 및 APT 관리는 주로 미들웨어를 통해 처리된다.
    - 효율적으로 애플리케이션을 구축할 수 있도록 지원
    - 애플리케이션, 데이터 밋 사용자 사이를 연결하는 요소처럼 작동
    - 미들웨어란? : [Azure](https://azure.microsoft.com/ko-kr/overview/what-is-middleware/), [Red Hat](https://www.redhat.com/ko/topics/middleware/what-is-middleware)
- `동적인 컨텐츠` (JSP, ASP, PHP 등) 를 요청받아 처리한다.
  - WEB 서버는 정적인 콘텐츠 (HTML, CSS , IMAGE 등)를 요청바당 처리
  
###### WEB와 WAS를 구분하는 이유
- **데이터 처리 방식** : 정적 컨텐츠 (WEB), 동적 컨텐츠 (WAS)
- **보안**: 요청은 WEB 서버가 받고 그 요청을 웹 서버가 WAS에 전달.
  - `WAS`는 DB에 대한 접속 정보가 있기 때문에 노출되면 X 
  - `WEB`은 DMZ구간에 위치, `WAS`는 내부망에 위치 

###### DI (Dependency Injection, 의존성 주입)
- DI 컨테이너를 통해 서로 강하게 결합 되어 있는 두 클래스를 분리
- 두 객체 간의 관계를 결정
- 결합도를 낮추고 유연성을 확보 
- 테스트 작성을 용이하게 함 
- Spring에서는 Bean들을 기본적으로 `싱글톤(Singleton)`으로 관리

###### request 기본 객체 
- 클라이언트(웹 브라우저)와 관련된 정보 읽기 
  - 클라이언트와 서버 정보(IP 주소, 요청 정보 길이, 인코딩, 컨텐츠의 타입, 프로토콜, 전송메서드, URL경로, 컨텍스트 경로, 서버이름, 포트 번호 )를 보여줌
  - 요청 파라미터 처리 
  - 요청 헤더 정보의 처리 
    - HTTP 프로토콜은 헤더 정보에 부가적인 정보를 담도록 하고 있다. 


###### response 기본 객체
-  request 기본 객체와 반대의 기능을 수행
- 웹 브라우저에 보내는 응답 정보를 담는다. 
  

- 헤더 정보 입력
  - add : 기존의 헤더에 새로운 값을 추가 
  - set : 헤더의 값을 새로 지정할 때 사용 
  

- 웹 브라우저 캐시 제어를 위한 응답 헤더 입력
   - DB가 바껴도 웹 브라우저에 출력되는 내용이 바뀌지 않는 경우가 있다. 
      - => 서버가 생성한 결과를 출력하지 않고 `캐시`에 저장된 데이터를 출력하기 때문
     > 캐시란(Cache) ? 
     > 
     >  동일한 데이터를 중복해서 로딩하지 않도록 할 때 사용.   
     > 
     > 웹 브라우저는 첫 번째 요청 시 응답 결과를 로컬 PC의 임시 보관소인 캐시에 저장한다. 이후, 동일한 URL에 대한 요청이 있으면 WAS에 접근하지 않고 로컬 PC에 저장된 응답 결과를 사용한다.
- 내용이 자주 바뀌지 않는 사이트는 캐시를 사용해서 보다 빠른 응답을 제공      
- HTTP는 특수한 응답 헤더를 통해서 웹 브라우저가 응답 결과를 캐시 할 것인가에 대한 여부를 설정할 수 있다. (Cache-Control "no-store" , Pragma, Expires)
  

- 리다이렉트 하기
  - 웹 브라우저에게 다른 페이지로 이동하라고 응답하는 기능
  
##### [JSP 기본 구조](https://www.yoogle.dev/jsp-02/)
- 디렉티브 : JSP 페이지에 대한 설정 정보 
- 표현식 (`<%= %>`) : 값을 출력
- 스크립트릿 (`<% %>`) : 자바 코드를 실행 
- 표현언어( el) : ` ${  } `
- 태그 : JSP 페이지에서 특별한 기능을 제공 
***
#### 정보처리기사 실기 : 1. 요구사항 확인 - 플랫폼, 운영체제

***
## 💡 오늘의 회고 💡

책을 읽고 정리하고 리뷰하는 repo를 새로 만들어야겠다. T.I.L이 너무 길어지기도 하고 정리한 내용을 다시 보려면 그게 나으니깐! 여러모로 github 정리를 해야겠다. 아직도 프로젝트는 소스만 올려놓고 정리를 못했으니 그것도 정리해야지.    

오늘은 바쁘게 하기로 정한 것을 조금이라도 하려고 했던거 같다. 효율적으로 시간 분배를 해서 한쪽으로 치우치지 않게 해야겠다. 알고리즘 푸는 것을 더 늘려야지.     

오늘도 학원에 가서 3시간 정도 공부를 했다. 확실히 학원에 있으면 뭔가 그 공간에서 주는 마음가짐(?)이라고 해야 하나 하여튼 딴짓을 하면 안 될 거 같은 기운에 나름 열심히 이것저것 했던 거 같다. 이제 내 붕붕이는 이별을 해서 부모님이 대전 가실 때 얻어타고 학원을 가야하지만 갈 수 있을 때 부지런히 가서 공부해야지.   
***

## 🎯 내일 할 일 🎯
1. [ ] 자료구조, 알고리즘 실전문제 
2. [ ] 자바 개념 공부하고 정리하기  
3. [ ] 팀 개발을 위한 Git.GitHub : chapter 5 실무 사례와 함께 Git 다루기 
4. [ ] 정보처리기사 실기 공부하고 정리하기 (효율적으로 하자)
5. [ ] 객체지향의 사실과 오해: 03 타입과 추상화
***
## 🏁 이번주 목표 🏁
- 이것이 코딩 테스트다 책 끝내기
- 프로그래머스 문제 풀기 
- 팀 개발을 위한 Git, GitHub 끝내기
- 객체지향의 사실과 오해 : 역할, 책임, 협력 관점에서 본 객체지향 끝내기
- 대화의 기술 읽기
- 자바 정리 
- 정보처리기사 실기 정리 